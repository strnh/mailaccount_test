"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetService = void 0;
var net_1 = __importDefault(require("net"));
var tls_1 = __importDefault(require("tls"));
var netConn_1 = require("./netConn");
var debug_1 = __importDefault(require("debug"));
var log = (0, debug_1.default)("node-tcp:netService");
var errorlog = (0, debug_1.default)("node-tcp:error:netService");
/**
 * NetService is a TCP or TLS server that listen on a port and create a NetConn for each connection
 */
var NetService = /** @class */ (function () {
    /**
     * Create a new NetService
     * @param port port to listen
     * @param connClass A class that extends NetConn
     * @param tlsOptions option for tls.createServer leave undefined for tcp server
     * @param options optional options for the NetConn
     */
    function NetService(portOrPath, connClass, tlsOptions, options) {
        var _this = this;
        this.acceptWaitingList = [];
        this.isClientAcceptConnections = false;
        this.port = portOrPath;
        this.tlsOptions = tlsOptions;
        this.options = options;
        if (!connClass) {
            connClass = netConn_1.NetConn;
        }
        this.connClass = connClass;
        this.serviceName = "".concat(connClass.name, "Service");
        if (tlsOptions) {
            this.tlsOptions = tlsOptions;
            this.server = tls_1.default.createServer(tlsOptions);
            this.serverType = "tls";
        }
        else {
            this.server = net_1.default.createServer();
            if (typeof this.port === "string" && this.port.startsWith("/")) {
                this.serverType = "unix";
            }
            else {
                this.serverType = "tcp";
            }
        }
        this.TAG = "".concat(this.serviceName, "_").concat(this.serverType, "_").concat(this.port);
        this.log = (0, debug_1.default)("node-tcp:netService:".concat(this.TAG));
        this.errorlog = (0, debug_1.default)("node-tcp:error:netService:".concat(this.TAG));
        var cs = this;
        if (connClass.name === "NetConn") {
            this.log("NetConn is the connClass. Set isClientAcceptConnections to true");
            this.isClientAcceptConnections = true;
        }
        if (this.serverType === "tcp" || this.serverType === "unix") {
            this.server.on('connection', function (socket) {
                cs.onConnection(socket);
            });
        }
        else {
            this.server.on('secureConnection', function (socket) {
                cs.onConnection(socket);
            });
        }
        this.server.on('close', function () {
            cs.onClose();
        });
        this.server.on('error', function (error) {
            cs.onError(error);
        });
        this.server.on('listening', function () {
            var addr = _this.server.address();
            if (addr && typeof addr !== "string") {
                _this.port = addr.port;
                _this.TAG = "".concat(_this.serviceName, "_").concat(_this.serverType, "_").concat(_this.port);
            }
            cs.log("Listening. port: ".concat(_this.port, ". serverType: ").concat(_this.serverType));
            if (_this.listenPromise) {
                _this.listenPromise.resolve();
                _this.listenPromise = undefined;
            }
        });
        cs.log("Create ".concat(this.serverType, " server on port ").concat(this.port));
    }
    /**
     * Listen for connections
     * @returns A promise that resolves when the server is listening
     */
    NetService.prototype.listen = function (options) {
        var ns = this;
        if (options && !options.port) {
            if (typeof this.port === "string" && this.port.startsWith("/")) {
                options.path = this.port;
            }
            else if (typeof this.port === "number") {
                options.port = this.port;
            }
            this.server.listen(options);
        }
        else {
            this.server.listen(this.port);
        }
        return new Promise(function (resolve, reject) {
            ns.listenPromise = {
                resolve: resolve,
                reject: reject
            };
        });
    };
    /**
     * Close the server and stop listening for connections
     */
    NetService.prototype.close = function () {
        if (this.server) {
            this.log("Close server");
            this.server.close();
        }
    };
    /**
     * Handle a new connection. Create a new NetConn and add event handlers
     * @param socket
     */
    NetService.prototype.onConnection = function (socket) {
        var _this = this;
        this.log("HandleConnection. remoteAddress: ".concat(socket.remoteAddress));
        var netConn = new this.connClass(socket, this, this.options);
        var errorHandler = function (err) {
            _this.errorlog("Connection error", err);
        };
        var closeHandler = function (err) {
            _this.log("".concat(_this.TAG, ": connection closed"));
            socket.end();
        };
        netConn.on("error", errorHandler);
        netConn.on("close", closeHandler);
        if (this.acceptPromise) {
            this.log("Found acceptPromise. resolve it");
            this.acceptPromise.resolve(netConn);
            this.acceptPromise = undefined;
        }
        else if (this.isClientAcceptConnections) {
            this.log("No acceptPromise. Add to waiting list");
            this.acceptWaitingList.push(netConn);
        }
        else {
            this.log("Client is not accepting connections. Expecting extended NetConn class to handle connection");
        }
    };
    /**
     * Accept a connection. If there is a connection waiting in the acceptWaitingList return it
     * otherwise return a promise that resolves when a connection is made
     * @returns A promise that resolves to a NetConn
     */
    NetService.prototype.accept = function () {
        var _this = this;
        var ns = this;
        return new Promise(function (resolve, reject) {
            ns.acceptPromise = {
                resolve: resolve,
                reject: reject
            };
            _this.log("Accept. acceptPromise: ".concat(ns.acceptPromise));
            if (ns.acceptWaitingList.length > 0) {
                var netConn = ns.acceptWaitingList.shift();
                if (netConn) {
                    _this.log("accept waiting list. resolve");
                    ns.acceptPromise.resolve(netConn);
                    ns.acceptPromise = undefined;
                }
            }
        });
    };
    /**
     * Handle server close event
     */
    NetService.prototype.onClose = function () {
        this.log("onClose");
        if (this.listenPromise) {
            this.listenPromise.reject(new Error("Server closed"));
            this.listenPromise = undefined;
        }
        if (this.acceptPromise) {
            this.acceptPromise.reject(new Error("Server closed"));
            this.acceptPromise = undefined;
        }
    };
    /**
     * Handle server error event. If there is a listenPromise reject it
     * @param error
     */
    NetService.prototype.onError = function (error) {
        this.errorlog("Error", error);
        if (this.listenPromise) {
            this.listenPromise.reject(error);
            this.listenPromise = undefined;
        }
    };
    return NetService;
}());
exports.NetService = NetService;
