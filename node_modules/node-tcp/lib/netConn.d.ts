/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import net from "net";
import tls from "tls";
import { EventEmitter } from "events";
import { SequentialTaskQueue } from "sequential-task-queue";
import { CompressedSocket } from "./compressedSocket";
import debug from "debug";
type BWStats = {
    addInBytes: (bytes: number) => void;
    addOutBytes: (bytes: number) => void;
};
/**
 * NetConn is a wrapper around a socket that provides a promise-based interface
 * for reading and writing data.
 * The class intended to be extended by other classes that provide higher-level
 * functionality.
 */
export declare class NetConn extends EventEmitter {
    TAG: string;
    socket: net.Socket;
    writeQ: SequentialTaskQueue;
    _err: Error | any;
    email?: string;
    bwStats?: BWStats;
    countBWStats: boolean;
    inBytes: number;
    outBytes: number;
    options?: any;
    log: debug.Debugger;
    compressIn: boolean;
    compressOut: boolean;
    compressedSocket?: CompressedSocket;
    readTimeout: number;
    /**
     * Create a new NetConn based on a socket
     * @param {net.Socket} socket
     */
    constructor(socket: net.Socket, server?: any, options?: any, errorLogger?: (...args: any[]) => any);
    /**
     * Connect to a TCP host or IPC socket and return a NetConn after the connection is established
     * @param options
     * @returns
     */
    static connectWithOptions(options: net.NetConnectOpts): Promise<NetConn>;
    /**
     * Connect to a host and return a NetConn after the connection is established
     * @param options
     * @param isTLS
     * @returns A NetConn object that wraps the socket
     */
    static connectToHost(options: net.TcpNetConnectOpts | tls.ConnectionOptions, isTLS?: boolean): Promise<NetConn>;
    /**
     * Connect to a host and return a net.Socket or tls.Socket after the connection is established
     * @param options connect options including host, port, etc.
     * @param isTLSs
     * @returns A net.Socket or tls.Socket object
     */
    static promiseConnect(options: net.TcpNetConnectOpts | tls.ConnectionOptions, isTLS?: boolean): Promise<net.Socket | tls.TLSSocket>;
    /**
     * Start to compress data on the socket in one or both directions.
     * If the socket is already compressed, this method does nothing.
     * Compression cannot be disabled once enabled.
     * @param compressIn
     * @param compressOut
     */
    setCompression(compressIn: boolean, compressOut: boolean): void;
    /**
     * Set the timeout on the socket
     * If an idle socket times out, it will be destroyed.
     * @param timeout The timeout in milliseconds, or 0 to disable
     */
    setTimeout(timeout: number): void;
    /**
     * Set the timeout on the socket for read operations
     * If a read operation times out, the read will be aborted.
     * @param timeout The timeout in milliseconds, or 0 to disable
     */
    setReadTimeout(timeout: number): void;
    /**
     * Read a Buffer from the socket
     * @param {*} size The number of bytes to read. If not specified, read all available data
     * @returns {Buffer} The data read from the socket
     */
    readBuffer(size?: number | undefined): Promise<Buffer>;
    /**
     * Flush the compression buffer. If it not compressed, this method does nothing.
     */
    flush(): Promise<void>;
    /**
     * Write buffer to socket
     * @param chunk
     * @param doNotCompressChunk
     * @returns Promise that will be resolved when buffer is written
     */
    writeBuffer(chunk: Buffer, writeUnCompressed?: boolean): Promise<void>;
    /**
     * Count output bytes for bandwidth stats
     * @param bytes
     */
    addOutBytes(bytes: number): void;
    /**
     * Count input bytes for bandwidth stats
     * @param bytes
     */
    addInBytes(bytes: number): void;
    /**
     * Close the socket
     * @returns Promise that will be resolved when socket is closed
     */
    end(): Promise<void>;
    /**
     * Read 32 bit integer
     * @returns Promise that will be resolved with the integer
     */
    readInt(): Promise<number>;
    /**
     * Read 8 bit integer (byte)
     * @returns
     */
    readByte(): Promise<number>;
    /**
     * Read boolean
     * @returns {boolean}
     */
    readBoolean(): Promise<boolean>;
    /**
     * Read float (32 bit) value
     * @returns {number}
     */
    readFloat(): Promise<number>;
    /**
     * Read big integer (64 bit) value
     * @returns {bigint}
     */
    readLong(): Promise<bigint>;
    /**
     * Read UTF string
     * @returns {string}
     */
    readUTF(): Promise<string>;
    /**
     * Read UTF string (old format. length is 16 bit)
     * @returns {string}
     */
    readUTFOld(): Promise<string>;
    /**
     * Read UTF string or null
     * @returns {string | null}
     */
    readString(): Promise<string | null>;
    /**
     * Read UTF string or null (old format. length is 16 bit)
     * @returns {string | null}
     */
    readStringOld(): Promise<string | null>;
    /**
     * Read byte array
     * @returns {Buffer} data
     */
    readByteArr(): Promise<Buffer>;
    /**
     * Read a JSON string and parse it
     * @returns The object or javascript value after parsing the JSON string
     */
    readJSON(): Promise<any>;
    /**
     * Write any object or javascript value as JSON string
     * @param obj
     */
    writeJSON(obj: any): Promise<void>;
    /**
     * Write 32 bit integer
     * @param num
     */
    writeInt(num: number): Promise<void>;
    /**
     * Write boolean
     * @param bool
     */
    writeBoolean(bool: boolean): Promise<void>;
    /**
     * Write string
     * @param {string} str
     */
    writeString(str: string | null): Promise<void>;
    /**
     * Write string
     * @param {string} str
     */
    writeStringOld(str: string | null): Promise<void>;
    /**
     * Write float (32 bit) value
     * @param {number} f
     */
    writeFloat(f: number): Promise<void>;
    /**
     * Write big integer (64 bit) value
     * @param {bigint} num
     */
    writeLong(num: bigint): Promise<void>;
}
export {};
