"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetConn = void 0;
var net_1 = __importDefault(require("net"));
var tls_1 = __importDefault(require("tls"));
var events_1 = require("events");
var sequential_task_queue_1 = require("sequential-task-queue");
var compressedSocket_1 = require("./compressedSocket");
var debug_1 = __importDefault(require("debug"));
// enable erorr logging
if (process.env.DEBUG) {
    debug_1.default.enable("".concat(process.env.DEBUG, ",node-tcp:error:*"));
}
else {
    debug_1.default.enable("node-tcp:error:*");
}
var log = (0, debug_1.default)("node-tcp:NetConn");
var errorlog = (0, debug_1.default)("node-tcp:error:NetConn");
var unsignedIntMax = 4294967295;
var signedShortMax = 32767;
/**
 * NetConn is a wrapper around a socket that provides a promise-based interface
 * for reading and writing data.
 * The class intended to be extended by other classes that provide higher-level
 * functionality.
 */
var NetConn = /** @class */ (function (_super) {
    __extends(NetConn, _super);
    /**
     * Create a new NetConn based on a socket
     * @param {net.Socket} socket
     */
    function NetConn(socket, server, options, errorLogger) {
        var _this = _super.call(this) || this;
        _this.countBWStats = false;
        _this.inBytes = 0;
        _this.outBytes = 0;
        _this.compressIn = false;
        _this.compressOut = false;
        _this.readTimeout = 0;
        if (errorLogger) {
            errorlog.log = errorLogger;
        }
        _this.socket = socket;
        _this.TAG = "".concat(Object.getPrototypeOf(_this).constructor.name, "_").concat(socket.remoteAddress, ":").concat(socket.remotePort);
        _this.log = (0, debug_1.default)("node-tcp:NetConn:".concat(_this.TAG));
        _this.log("constructor");
        _this.options = options;
        socket.setNoDelay(true);
        _this.writeQ = new sequential_task_queue_1.SequentialTaskQueue();
        var writeQErrorHandler = function (err) {
            _this.log("writeQ error: ".concat(err));
        };
        _this.writeQ.on("error", writeQErrorHandler);
        var nc = _this;
        var errorHandler = function (err) {
            nc.log("Error on socket", err);
            nc._err = err;
        };
        var closeHandler = function () {
            nc.log("Socket closed");
            nc.socket.removeListener("error", errorHandler);
            nc.socket.removeListener("close", closeHandler);
            nc.emit('close');
        };
        var timeoutHandler = function () {
            nc.log("Socket timeout");
            try {
                nc.socket.destroy(new Error("Socket timeout"));
            }
            catch (err) {
                // ignore
            }
        };
        _this.socket.on("error", errorHandler);
        _this.socket.on("close", closeHandler);
        _this.socket.on('timeout', timeoutHandler);
        return _this;
    }
    /**
     * Connect to a TCP host or IPC socket and return a NetConn after the connection is established
     * @param options
     * @returns
     */
    NetConn.connectWithOptions = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var socket;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log("connectWithOptions. options: ".concat(JSON.stringify(options, null, 2)));
                        return [4 /*yield*/, NetConn.promiseConnect(options)];
                    case 1:
                        socket = _a.sent();
                        return [2 /*return*/, new NetConn(socket)];
                }
            });
        });
    };
    /**
     * Connect to a host and return a NetConn after the connection is established
     * @param options
     * @param isTLS
     * @returns A NetConn object that wraps the socket
     */
    NetConn.connectToHost = function (options, isTLS) {
        if (isTLS === void 0) { isTLS = false; }
        return __awaiter(this, void 0, void 0, function () {
            var socket;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log("connectToHost. host: ".concat(options.host, ", port: ").concat(options.port, ", isTLS: ").concat(isTLS));
                        return [4 /*yield*/, NetConn.promiseConnect(options, isTLS)];
                    case 1:
                        socket = _a.sent();
                        return [2 /*return*/, new NetConn(socket)];
                }
            });
        });
    };
    /**
     * Connect to a host and return a net.Socket or tls.Socket after the connection is established
     * @param options connect options including host, port, etc.
     * @param isTLSs
     * @returns A net.Socket or tls.Socket object
     */
    NetConn.promiseConnect = function (options, isTLS) {
        if (isTLS === void 0) { isTLS = false; }
        return new Promise(function (resolve, reject) {
            var socket;
            var connectHandler = function () {
                log("connected");
                socket.removeListener("error", errorHandler);
                resolve(socket);
            };
            var errorHandler = function (err) {
                log("connect error", err);
                socket.removeListener("connect", connectHandler);
                reject(err);
            };
            if (isTLS) {
                socket = tls_1.default.connect(options, connectHandler).once("error", errorHandler);
            }
            else {
                socket = net_1.default.connect(options, connectHandler).once("error", errorHandler);
            }
        });
    };
    /**
     * Start to compress data on the socket in one or both directions.
     * If the socket is already compressed, this method does nothing.
     * Compression cannot be disabled once enabled.
     * @param compressIn
     * @param compressOut
     */
    NetConn.prototype.setCompression = function (compressIn, compressOut) {
        if (compressIn && this.compressIn === false) {
            if (!this.compressedSocket) {
                this.compressedSocket = new compressedSocket_1.CompressedSocket(this.socket);
            }
            this.compressIn = true;
        }
        if (compressOut) {
            if (!this.compressedSocket) {
                this.compressedSocket = new compressedSocket_1.CompressedSocket(this.socket);
            }
            this.compressOut = true;
        }
    };
    /**
     * Set the timeout on the socket
     * If an idle socket times out, it will be destroyed.
     * @param timeout The timeout in milliseconds, or 0 to disable
     */
    NetConn.prototype.setTimeout = function (timeout) {
        this.socket.setTimeout(timeout);
    };
    /**
     * Set the timeout on the socket for read operations
     * If a read operation times out, the read will be aborted.
     * @param timeout The timeout in milliseconds, or 0 to disable
     */
    NetConn.prototype.setReadTimeout = function (timeout) {
        this.readTimeout = timeout;
    };
    /**
     * Read a Buffer from the socket
     * @param {*} size The number of bytes to read. If not specified, read all available data
     * @returns {Buffer} The data read from the socket
     */
    NetConn.prototype.readBuffer = function (size) {
        var _this = this;
        var nc = this;
        nc.log("readBuffer. size: ".concat(size));
        var stream;
        if (this.compressIn && this.compressedSocket) {
            stream = this.compressedSocket;
        }
        else {
            stream = this.socket;
        }
        return new Promise(function (resolve, reject) {
            if (nc._err) {
                reject(nc._err);
                return;
            }
            if (!_this.socket || _this.socket.destroyed) {
                reject(new Error("Socket destroyed"));
                return;
            }
            var isResolved = false;
            // try to read immediately
            try {
                var chunk = stream.read(size);
                if (chunk) {
                    var chunkSize = chunk.length;
                    nc.log("readBuffer. resolve: ".concat(chunkSize));
                    if (_this.bwStats || _this.countBWStats) {
                        _this.addInBytes(chunkSize);
                    }
                    resolve(chunk);
                    return;
                }
            }
            catch (err) {
                nc.log("readBuffer error: ".concat(err));
                reject(err);
                return;
            }
            var readableHandler = function () {
                nc.log("readBuffer. readableHandler");
                try {
                    var chunk = stream.read(size);
                    if (chunk) {
                        var chunkSize = chunk.length;
                        nc.log("readBuffer. resolve: ".concat(chunkSize));
                        removeListeners();
                        if (!isResolved) {
                            isResolved = true;
                            if (_this.bwStats || _this.countBWStats) {
                                _this.addInBytes(chunkSize);
                            }
                            resolve(chunk);
                        }
                        return;
                    }
                    else {
                        nc.log("readBuffer. read returned null");
                    }
                }
                catch (err) {
                    nc.log("readBuffer error: ".concat(err));
                    removeListeners();
                    if (!isResolved) {
                        isResolved = true;
                        reject(err);
                    }
                }
            };
            var closeHandler = function () {
                nc.log("readBuffer closeHandler");
                removeListeners();
                if (!isResolved) {
                    isResolved = true;
                    reject(new Error("Connection closed"));
                }
            };
            var endHandler = function () {
                nc.log("readBuffer endHandler");
                removeListeners();
                if (!isResolved) {
                    isResolved = true;
                    reject(new Error("Connection ended"));
                }
            };
            var errorHandler = function (err) {
                nc.log("readBuffer errorHandler: " + err);
                removeListeners();
                if (!isResolved) {
                    isResolved = true;
                    reject(err);
                }
            };
            var readTimeoutHandler = function () {
                nc.log("readBuffer readTimeoutHandler");
                removeListeners();
                if (!isResolved) {
                    isResolved = true;
                    reject(new Error("Read timeout"));
                }
            };
            var readTimeout;
            var removeListeners = function () {
                stream.removeListener("close", closeHandler);
                stream.removeListener("error", errorHandler);
                stream.removeListener("end", endHandler);
                stream.removeListener("readable", readableHandler);
                if (readTimeout) {
                    clearTimeout(readTimeout);
                    readTimeout = undefined;
                }
            };
            nc.log("readBuffer. wait to readable");
            stream.on('readable', readableHandler);
            stream.on("close", closeHandler);
            stream.on("end", endHandler);
            stream.on("error", errorHandler);
            if (nc.readTimeout) {
                // nc.log(`readBuffer. set timeout: ${nc.readTimeout}`);
                readTimeout = setTimeout(readTimeoutHandler, nc.readTimeout);
            }
        });
    };
    /**
     * Flush the compression buffer. If it not compressed, this method does nothing.
     */
    NetConn.prototype.flush = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.compressedSocket && this.compressOut)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.compressedSocket.compressAndSend()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Write buffer to socket
     * @param chunk
     * @param doNotCompressChunk
     * @returns Promise that will be resolved when buffer is written
     */
    NetConn.prototype.writeBuffer = function (chunk, writeUnCompressed) {
        var _this = this;
        if (writeUnCompressed === void 0) { writeUnCompressed = false; }
        if (this.compressOut && this.compressedSocket) {
            if (this.bwStats || this.countBWStats) {
                this.addOutBytes(chunk.length);
            }
            return this.compressedSocket.writeBuffer(chunk);
        }
        var nc = this;
        return new Promise(function (resolve, reject) {
            if (nc._err) {
                reject(nc._err);
                return;
            }
            if (!_this.socket || _this.socket.destroyed) {
                reject(new Error("Socket destroyed"));
                return;
            }
            var haveListeners = true;
            var writeHandler = function () {
                if (haveListeners) {
                    nc.log("writeBuffer. writeHandler");
                    removeListeners();
                    resolve();
                }
            };
            var closeHandler = function () {
                if (haveListeners) {
                    nc.log("writeBuffer. Connection closed");
                    removeListeners();
                    reject(new Error("writeBuffer: Connection closed"));
                }
            };
            var endHandler = function () {
                if (haveListeners) {
                    nc.log("writeBuffer. Connection ended");
                    removeListeners();
                    reject(new Error("writeBuffer: Connection ended"));
                }
            };
            var errorHandler = function (err) {
                if (haveListeners) {
                    nc.log("writeBuffer. Error: ".concat(err));
                    removeListeners();
                    reject(err);
                }
            };
            var removeListeners = function () {
                haveListeners = false;
                nc.socket.removeListener("close", closeHandler);
                nc.socket.removeListener("error", errorHandler);
                nc.socket.removeListener("end", endHandler);
            };
            nc.socket.on("close", closeHandler);
            nc.socket.on("end", endHandler);
            nc.socket.on("error", errorHandler);
            try {
                nc.log("writeBuffer. write ".concat(chunk.length, " bytes"));
                nc.socket.write(chunk, writeHandler);
                if (_this.bwStats || _this.countBWStats) {
                    _this.addOutBytes(chunk.length);
                }
            }
            catch (err) {
                nc.log("write error: ".concat(err));
                errorHandler(err);
            }
        });
    };
    /**
     * Count output bytes for bandwidth stats
     * @param bytes
     */
    NetConn.prototype.addOutBytes = function (bytes) {
        if (this.bwStats) {
            this.bwStats.addOutBytes(bytes);
        }
        else {
            if (!this.outBytes) {
                this.outBytes = 0;
            }
            this.outBytes += bytes;
        }
    };
    /**
     * Count input bytes for bandwidth stats
     * @param bytes
     */
    NetConn.prototype.addInBytes = function (bytes) {
        if (this.bwStats) {
            this.bwStats.addInBytes(bytes);
        }
        else {
            this.inBytes += bytes;
        }
    };
    /**
     * Close the socket
     * @returns Promise that will be resolved when socket is closed
     */
    NetConn.prototype.end = function () {
        var nc = this;
        nc.log("end");
        return new Promise(function (resolve, reject) {
            nc.socket.end(function () {
                resolve();
            });
        });
    };
    /**
     * Read 32 bit integer
     * @returns Promise that will be resolved with the integer
     */
    NetConn.prototype.readInt = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chunk;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readBuffer(4)];
                    case 1:
                        chunk = _a.sent();
                        return [2 /*return*/, chunk.readInt32BE()];
                }
            });
        });
    };
    /**
     * Read 8 bit integer (byte)
     * @returns
     */
    NetConn.prototype.readByte = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chunk;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readBuffer(1)];
                    case 1:
                        chunk = _a.sent();
                        return [2 /*return*/, chunk.readInt8()];
                }
            });
        });
    };
    /**
     * Read boolean
     * @returns {boolean}
     */
    NetConn.prototype.readBoolean = function () {
        return __awaiter(this, void 0, void 0, function () {
            var b;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readByte()];
                    case 1:
                        b = _a.sent();
                        if (b !== 0) {
                            return [2 /*return*/, true];
                        }
                        else {
                            return [2 /*return*/, false];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Read float (32 bit) value
     * @returns {number}
     */
    NetConn.prototype.readFloat = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chunk;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readBuffer(4)];
                    case 1:
                        chunk = _a.sent();
                        return [2 /*return*/, chunk.readFloatBE()];
                }
            });
        });
    };
    /**
     * Read big integer (64 bit) value
     * @returns {bigint}
     */
    NetConn.prototype.readLong = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chunk;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readBuffer(8)];
                    case 1:
                        chunk = _a.sent();
                        return [2 /*return*/, chunk.readBigInt64BE()];
                }
            });
        });
    };
    /**
     * Read UTF string
     * @returns {string}
     */
    NetConn.prototype.readUTF = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chunk, strlen, chunk2, text;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readBuffer(4)];
                    case 1:
                        chunk = _a.sent();
                        strlen = chunk.readUint32BE();
                        if (!(strlen > 0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.readBuffer(strlen)];
                    case 2:
                        chunk2 = _a.sent();
                        text = chunk2.toString('utf8');
                        return [2 /*return*/, text];
                    case 3: return [2 /*return*/, ""];
                }
            });
        });
    };
    /**
     * Read UTF string (old format. length is 16 bit)
     * @returns {string}
     */
    NetConn.prototype.readUTFOld = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chunk, strlen, chunk2, text;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readBuffer(2)];
                    case 1:
                        chunk = _a.sent();
                        strlen = chunk.readInt16BE();
                        if (!(strlen > 0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.readBuffer(strlen)];
                    case 2:
                        chunk2 = _a.sent();
                        text = chunk2.toString('utf8');
                        return [2 /*return*/, text];
                    case 3: return [2 /*return*/, ""];
                }
            });
        });
    };
    /**
     * Read UTF string or null
     * @returns {string | null}
     */
    NetConn.prototype.readString = function () {
        return __awaiter(this, void 0, void 0, function () {
            var isNull, text;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readBoolean()];
                    case 1:
                        isNull = _a.sent();
                        text = null;
                        if (!!isNull) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.readUTF()];
                    case 2:
                        text = _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, text];
                }
            });
        });
    };
    /**
     * Read UTF string or null (old format. length is 16 bit)
     * @returns {string | null}
     */
    NetConn.prototype.readStringOld = function () {
        return __awaiter(this, void 0, void 0, function () {
            var isNull, text;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readBoolean()];
                    case 1:
                        isNull = _a.sent();
                        text = null;
                        if (!!isNull) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.readUTFOld()];
                    case 2:
                        text = _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, text];
                }
            });
        });
    };
    /**
     * Read byte array
     * @returns {Buffer} data
     */
    NetConn.prototype.readByteArr = function () {
        return __awaiter(this, void 0, void 0, function () {
            var len, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readInt()];
                    case 1:
                        len = _a.sent();
                        return [4 /*yield*/, this.readBuffer(len)];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, data];
                }
            });
        });
    };
    /**
     * Read a JSON string and parse it
     * @returns The object or javascript value after parsing the JSON string
     */
    NetConn.prototype.readJSON = function () {
        return __awaiter(this, void 0, void 0, function () {
            var str;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readString()];
                    case 1:
                        str = _a.sent();
                        if (str) {
                            return [2 /*return*/, JSON.parse(str)];
                        }
                        else {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Write any object or javascript value as JSON string
     * @param obj
     */
    NetConn.prototype.writeJSON = function (obj) {
        return __awaiter(this, void 0, void 0, function () {
            var str;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        str = JSON.stringify(obj);
                        return [4 /*yield*/, this.writeString(str)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Write 32 bit integer
     * @param num
     */
    NetConn.prototype.writeInt = function (num) {
        return __awaiter(this, void 0, void 0, function () {
            var b;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        b = Buffer.alloc(4);
                        b.writeInt32BE(num);
                        return [4 /*yield*/, this.writeBuffer(b)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Write boolean
     * @param bool
     */
    NetConn.prototype.writeBoolean = function (bool) {
        return __awaiter(this, void 0, void 0, function () {
            var b;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        b = Buffer.alloc(1);
                        b.writeInt8(bool ? 1 : 0);
                        return [4 /*yield*/, this.writeBuffer(b)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Write string
     * @param {string} str
     */
    NetConn.prototype.writeString = function (str) {
        return __awaiter(this, void 0, void 0, function () {
            var strbuf, b;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!str) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.writeBoolean(true)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                    case 2:
                        strbuf = Buffer.from(str, 'utf8');
                        if (strbuf.length > unsignedIntMax) {
                            throw new Error("String too long: ".concat(strbuf.length, " bytes"));
                        }
                        b = Buffer.alloc(5);
                        b.writeInt8(0);
                        b.writeUInt32BE(strbuf.length, 1);
                        return [4 /*yield*/, this.writeBuffer(b)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.writeBuffer(strbuf)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Write string
     * @param {string} str
     */
    NetConn.prototype.writeStringOld = function (str) {
        return __awaiter(this, void 0, void 0, function () {
            var strbuf, b;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!str) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.writeBoolean(true)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                    case 2:
                        strbuf = Buffer.from(str, 'utf8');
                        if (strbuf.length > signedShortMax) {
                            throw new Error("String too long: ".concat(strbuf.length, " bytes"));
                        }
                        b = Buffer.alloc(3);
                        b.writeInt8(0);
                        b.writeInt16BE(strbuf.length, 1);
                        return [4 /*yield*/, this.writeBuffer(b)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.writeBuffer(strbuf)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Write float (32 bit) value
     * @param {number} f
     */
    NetConn.prototype.writeFloat = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var b;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        b = Buffer.alloc(4);
                        b.writeFloatBE(f);
                        return [4 /*yield*/, this.writeBuffer(b)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Write big integer (64 bit) value
     * @param {bigint} num
     */
    NetConn.prototype.writeLong = function (num) {
        return __awaiter(this, void 0, void 0, function () {
            var b;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        b = Buffer.alloc(8);
                        b.writeBigInt64BE(num);
                        return [4 /*yield*/, this.writeBuffer(b)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return NetConn;
}(events_1.EventEmitter));
exports.NetConn = NetConn;
